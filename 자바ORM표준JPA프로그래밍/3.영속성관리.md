# 3장 영속성 관리
## [전체 JPA 문서](index.md)

## 3.1 엔티티 매니저 팩토리와 엔티티 매니저 
- [2.6.1 엔티티 매니저 설정 참조](2.JPA시작.md#261-엔티티-매니저-설정)
## 3.2 영속성 컨텍스트란? 
- 영속성 컨텍스트는 엔티티를 영구 저장하는 환경을 의미한다.
## 3.3 엔티티의 생명주기 
- 비영속
  - 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 엔티티 객체가 처음 생성될 경우 이 객체는 순수한 객체 상태로 영속성 컨텍스트와 관계가 없다. 이런 상태를 비영속 상태라고 한다.
- 영속
  - 영속성 컨텍스트에 저장된 상태
  - find()나 JPQL에 의해 조회된 엔티티도 영속 상태이다.
- 준영속
  - 영속성 컨텍스트에서 분리된 상태
  - 영속성 컨텍스트에 저장된 이후 detach(), close(), clear() 등에 의해 더이상 컨텍스트에 의해 관리되지 않는 것을 준영속 상태라고 한다.
- 삭제
  - 영속성 컨텍스트에서 제거된 상태
  - 영속성 컨텍스트와 데이터베이스 모두에서 제거된다.
## 3.4 영속성 컨텍스트의 특징 
- 영속성 컨텍스트는 식별자 필드로 엔티티를 구분하므로 영속 상태의 엔티티는 식별자 값을 반드시 가지고 있어야 한다.
- 영속성 컨텍스트는 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연 로딩을 지원한다.
### 3.4.1 엔티티 조회 
- 영속성 컨텍스트는 내부에 메모리를 가지고 있는데 이를 1차 캐시라 하고 영속 상태의 엔티티는 모두 이곳에 저장된다.
- 엔티티를 조회할 경우 먼저 1차 캐시를 탐색하고 없다면 DB에서 조회한 뒤 1차 캐시에 저장하고 저장된 엔티티를 반환한다. 그러므로 같은 영속성 컨텍스트에서 같은 엔티티를 조회하면 동일성과 동등성이 모두 보장된다.
### 3.4.2 엔티티 등록 
- 엔티티 매니저는 엔티티가 저장되더라도 트랜잭션을 커밋하기 전까지는 데이터베이스에 엔티티를 저장하지 않는다. 그리고 트랜잭션이 커밋될 때 저장할 엔티티들의 INSERT SQL을 한번에 데이터베이스에 전송하는데 이를 트랜잭션을 지원하는 쓰기 지연이라 한다.
### 3.4.3 엔티티 수정 
- SQL을 직접 다루는 방식에서 수정 쿼리를 작성하게 되면 일부 컬럼만 수정해야 할 경우 개발자가 각각의 수정 쿼리를 모두 작성해야 하는 문제가 있다.
- 하지만 JPA에서는 영속 상태인 엔티티가 수정되면 별도의 메소드 호출 없이 자동으로 엔티티의 변경사항을 데이터베이스에 저장하는데 이를 변경 감지라고 한다.
- JPA는 기본적으로 수정 쿼리를 재사용 하기 위해 모든 필드를 업데이트한다.
- 하지만 필드가 많거나 저장할 내용이 클 경우 엔티티에 `@org.hibernate.annotations.DynamicUpdate` 어노테이션을 사용해 동적으로 UPDATE SQL을 생성하도록 설정할 수 있다.
### 3.4.4 엔티티 삭제 
- 엔티티를 제거하려면 우선 삭제할 엔티티를 영속상태로 만들어야 한다.
- remove()를 호출해도 트랜잭션이 커밋되기 전까지는 데이터베이스에 남아있지만 엔티티 매니저에서는 즉시 제거된다.
## 3.5 플러시 
- 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.
- 플러시 호출
  - 직접 호출
    - flush()를 직접 호출한다.
    - 테스트나 다른 프레임워크와 JPA를 함께 사용할 때를 제외하고 거의 사용되지 않는다.
  - 트랜잭션 커밋
    - 변경사항을 데이터베이스에 적용하기 위해 트랜잭션이 커밋될 때 자동으로 플러시가 호출된다.
  - JPQL 쿼리 실행
    - JPQL은 데이터베이스에서 직접 실행되므로 이전에 수정된 엔티티가 아직 데이터베이스에 반영되지 않았으면 잘못된 결과가 나오게 된다. 이를 방지하기 위해 JPQL 등의 객체지향 쿼리가 실행되기 전에 자동으로 플러시가 실행된다.
### 3.5.1 플러시 모드 옵션 
- javax.persistence.FlushModeType을 지정해 플러시 모드를 변경할 수 있다.
- FlushModeType.AUTO는 커밋과 쿼리 모두 플러시를 실행한다.
- FlushModeType.COMMIT은 커밋할 때만 플러시를 실행한다.
## 3.6 준영속 
- 준영속 상태의 특징 
  - 영속성 컨텍스트가 관리하지 않으므로 거의 비영속 상태에 가깝다.
  - 영속 상태였으므로 식별자 값을 가지고 있다.
  - 지연 로딩을 할 수 없다.
- 병합: merge( ) 
  -  merge는 persist와 달리 넘겨준 엔티티를 한번 조회해서 1차 캐시에 저장한 뒤, 넘겨준 엔티티의 정보를 저장된 엔티티에 복사하고 저장된 엔티티를 반환한다.
  -  그렇기 때문에 넘겨준 엔티티와 반환된 엔티티는 서로 다른 객체이기 때문에 병합에 사용된 엔티티는 더이상 사용해선 안된다.
-  비영속 병합
   -  merge는 비영속 상태인 엔티티도 영속 상태로 만들 수 있다.
   -  그러므로 병합은 식별자를 조회해 저장된 엔티티가 존재하면 수정하고 없으면 추가하는 **INSERT OR UPDATE**의 기능을 수행한다.

## [맨 위로](#)